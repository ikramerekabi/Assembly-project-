
/*
    This is just a skeleton. It DOES NOT implement all the requirements.
    It only recognizes the RV32I "ADD", "SUB" and "ADDI" instructions only.
    It prints "Unkown Instruction" for all other instructions!

    Usage example:
        $ rvcdiss t1.bin
    should print out:
        0x00000000    0x00100013    ADDI    x0, x0, 0x1
        0x00000004    0x00100093    ADDI    x1, x0, 0x1
        0x00000008    0x00100113    ADDI    x2, x0, 0x1
        0x0000000c    0x001001b3    ADD        x3, x0, x1
        0x00000010    0x00208233    ADD        x4, x1, x2
        0x00000014    0x004182b3    ADD        x5, x3, x4
        0x00000018    0x00100893    ADDI    x11, x0, 0x1
        0x0000001c    0x00028513    ADDI    xa, x5, 0x0
        0x00000020    0x00000073    Unkown Instruction

    References:
    (1) The risc-v ISA Manual ver. 2.1 @ https://riscv.org/specifications/
    (2) https://github.com/michaeljclark/riscv-meta/blob/master/meta/opcodes
*/

#include <iostream>
#include <fstream>
#include "stdlib.h"
#include <iomanip>

using namespace std;

unsigned int pc = 0x0;

char memory[8 * 1024];    // only 8KB of memory located at address 0

void emitError(string s)
{
    cout << s;
    exit(0);
}

void printPrefix(unsigned int instA, unsigned int instW) {
    cout << "0x" << hex << std::setfill('0') << std::setw(8) << instA << "\t0x" << std::setw(8) << instW;
}

void instDecExec(unsigned int instWord)
{
    unsigned int t0,t1, t2, t3, rd, rs1, rs2, funct3, funct7, opcode, I_mm_shift, I_mm_S_type_4_0, I_mm_S_type_11_5, I_mm_S_type;
    unsigned int rd_C, rs1_C, Imm_C_2,Imm_C_6, Imm_C_5_3, rs2_C, funct3_C, Imm_C_load, nzImm_4_0, nzImm_5, rd_rs1, I_imm_C;
    unsigned int opcode_16;
    unsigned int I_imm, S_imm, B_imm, U_imm, J_imm;
    unsigned int address;
    unsigned int rs1_rd_dash, funct2;  

    unsigned int instPC = pc - 4;

    opcode_16 = instWord & 0x00000003;
    opcode = instWord & 0x0000007F;
    rd = (instWord >> 7) & 0x0000001F;
    I_mm_S_type_4_0 = rd;
    funct3 = (instWord >> 12) & 0x00000007;
    rs1 = (instWord >> 15) & 0x0000001F;
    rs2 = (instWord >> 20) & 0x0000001F;
    funct7 = (instWord >> 25) & 0x0000007F;
    I_mm_S_type_11_5 = funct7;
    I_mm_shift = (instWord >> 20) & 0x0000001F;
	t0 = I_mm_S_type_11_5 & 0x07F;
	t0 = t0 << 5;
	I_mm_S_type = (t0 | I_mm_S_type_4_0);
    // — inst[31] — inst[30:25] inst[24:21] inst[20]
    I_imm = ((instWord >> 20) & 0x7FF) | (((instWord >> 31) ? 0xFFFFF800 : 0x0));
    I_mm_shift = (instWord >> 20) & 0x0000001F;  //for SLLI, SRLI, SRAI


    //for compressed instructions
    rd_C = (instWord >> 2) & 0x0007;
    Imm_C_6 = (instWord >> 5) & 0x0001;    
    Imm_C_2 = (instWord >> 6) & 0x0001;
    rs1_C = (instWord >> 7) & 0x0007;
    Imm_C_5_3 = (instWord >> 10) & 0x0007;

    funct3_C = (instWord >> 13) & 0x0007;

    t1 = (Imm_C_6 & 0x001)<<6; // can we just and it with 0x1 instead of 0x001?????? 
    t2 = (Imm_C_5_3 & 0x007)<<5; // same question for these? ????????????
    Imm_C_load = t1 | t2;
    t3 = (Imm_C_2 & 0x001)<<2; 
    Imm_C_load = Imm_C_load | t3;

   //for compressed I types 

    nzImm_4_0 = (instWord >> 2) & 0x001F; // store bits from 0 to 4 from the immediate 
    rd_rs1 = (instWord >> 7 ) & 0x003F;   // store the bits of rd/rs 
    nzImm_5= (instWord >> 11 ) & 0x0001;  // store the last bit of the immediate 

    I_imm_C= ((nzImm_5 & 0x1) <<4 ) | (nzImm_4_0 & 0x1F);// put back the values of the immediate together. 

    rs1_rd_dash = (instWord >> 7 ) & 0x000F;  // store the value of rs1'/ rd'
    funct2 = (instWord >> 11 ) & 0x0003;      // store funct2 value 


    
    




    if (opcode_16 == 0x3)
    {
        printPrefix(instPC, instWord);
        // R instructions 
        if (opcode == 0x33) {       
            switch (funct3) {
            case 0: if (funct7 == 32) {
                cout << "\tSUB\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
            }
                    else {
                cout << "\tADD\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
            }
                    break;

            case 2:
                cout << "\tSLT\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                break;

            case 1:
                cout << "\tSLL\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                break;
            
            case 3:
                cout << "\tSLTU\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                break;

            case 4:
                cout << "\tXOR\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                break;

            case 5: if (funct7 == 32)
                {
                cout << "\tSRA\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                }
                    else {
                cout << "\tSRL\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                }
                break;

            case 6:
                cout << "\tOR\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";
                break;

            case 7:
                cout << "\tAND\tx" << rd << ", x" << rs1 << ", x" << rs2 << "\n";

                break;
                
            default:
                cout << "\tUnkown R Instruction \n";
            }
        } 
        // I instructions
        else if (opcode == 0x13) {    
            switch (funct3) {
            case 0:    cout << "\tADDI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_imm << "\n";
                break;
            case 2:  cout << "\tSLTI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_imm << "\n";
                        break;
            case 3:  cout << "\tSLTIU\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_imm << "\n";
                        break;
            case 4:  cout << "\tXORI\tx" << rd << ", x" << rs1 << ", " <<  hex << "0x" << (int)I_imm << "\n";
                        break;
            case 6:  cout << "\tORI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_imm << "\n";
                        break;
            case 7:  cout << "\tANDI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_imm << "\n";
                        break;
            case 1:  cout << "\tSLLI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_mm_shift << "\n";
                        break;
            case 5: if (funct7 == 32){
                    cout << "\tSRAI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_mm_shift << "\n";
                }else{
                    cout << "\tSRLI\tx" << rd << ", x" << rs1 << ", " << hex << "0x" << (int)I_mm_shift << "\n";
                }
                        break;
            default:
            cout << "\tUnkown I Instruction \n";
                }
        }
        // S instructions
        else if (opcode == 0x23) 
        {
            switch (funct3) {
            case 0:	cout << "\tSB\tx" << rs2 <<  ", " << hex << "0x" << (int)I_mm_S_type << "(x"<< rs1<< ")"<<"\n";
                break;
            case 1:  cout << "\tSH\tx" << rs2 << ", " << hex << "0x" << (int)I_mm_S_type << "(x" << rs1 << ")" << "\n";
                break;
            case 2:  cout << "\tSW\tx" << rs2 << ", " << hex << "0x" << (int)I_mm_S_type << "(x" << rs1 << ")" << "\n";
                break;
            default:
                cout << "\tUnkown S Instruction \n";
            }
        }
        //I instructions (load instructions)
        else if (opcode == 0x3) { 
            switch (funct3) {
                case 0:  cout << "\tLB\tx" << rd << ", 0x" << hex << (int)I_imm << "(x"<< rs1 <<  ")" << "\n";
                    break;
                case 1:  cout << "\tLH\tx" << rd << ", 0x" << hex << (int)I_imm << "(x"<< rs1 <<  ")" << "\n";
                    break;
                case 2:  cout << "\tLW\tx" << rd << ", 0x" << hex << (int)I_imm << "(x"<< rs1 <<  ")" << "\n";
                    break;
                case 4:  cout << "\tLBU\tx" << rd << ", 0x" << hex << (int)I_imm << "(x"<< rs1 <<  ")" << "\n";
                    break;
                case 5:  cout << "\tLHU\tx" << rd << ", 0x" << hex << (int)I_imm << "(x"<< rs1 <<  ")" << "\n";
                    break;
                default:
            cout << "\tUnkown I Instruction \n";
                    
            }
            
        }
        else {
            cout << "\tUnkown Instruction \n";
        }

        }
    else{
    // Compressed instructions
    if (opcode_16 == 0x0) {
            switch (funct3) {
            case 2:  cout << "\tC.LW\tx" << rd_C << ", 0x" << hex << (int)Imm_C_load << "(x" << rs1_C << ")" << "\n";
                break;

            case 6: cout << "\tC.SW\tx" << rd_C << ", 0x" << hex << (int)Imm_C_load << "(x" << rs1_C << ")" << "\n";
                break;   
            }
           

    }else if (opcode_16 == 0x1){
           switch (funct3) {
            // compressed I instructions 
            case 0:  cout << "\tC.ADDI\tx" << rd_rs1 << ", x" << rd_rs1 << ", " << hex << "0x" << (int) I_imm_C << "\n";
                break;
            case 4: if (funct2 == 0 ){
                cout << "\tC.SRLI\tx" << rs1_rd_dash << ", x" << rs1_rd_dash << ", " << hex << "0x" << (int) I_imm_C << "\n";
                break;
            }else if (funct2 == 1 ){
                cout << "\tC.SRAI\tx" << rs1_rd_dash << ", x" << rs1_rd_dash << ", " << hex << "0x" << (int) I_imm_C << "\n";
                break;
            }else if (funct2 === 2 ){
                cout << "\tC.ANDI\tx" << rs1_rd_dash << ", x" << rs1_rd_dash << ", " << hex << "0x" << (int) I_imm_C << "\n";
                break;  // in the instruction it is written as imm not nzimm , would it make a diff when coding ? should we add extra conditions? 
            }

           }
    }else if (opcode_16 == 0x2){
           switch (funct3) {
            case 0:  cout << "\tC.SLLI\tx" << rd_rs1 << ", x" << rd_rs1 << ", " << hex << "0x" << (int) I_imm_C << "\n";
                break;
           


           }
    }else {
            cout << "\tUnkown Compresssed Instruction \n";
        }
}
}

int main(int argc, char* argv[]) {

    unsigned int instWord = 0;
    ifstream inFile;
    ofstream outFile;

    if (argc < 2) emitError("use: rvcdiss <machine_code_file_name>\n");

    inFile.open(argv[1], ios::in | ios::binary | ios::ate);

    if (inFile.is_open())
    {
        int fsize = inFile.tellg();

        inFile.seekg(0, inFile.beg);
        if (!inFile.read((char*)memory, fsize)) emitError("Cannot read from input file\n");

        while (true) {
            instWord = (unsigned char)memory[pc] |
                (((unsigned char)memory[pc + 1]) << 8) |
                (((unsigned char)memory[pc + 2]) << 16) |
                (((unsigned char)memory[pc + 3]) << 24);
            pc += 4;
            // remove the following line once you have a complete simulator
            if (pc == fsize+4) break;            // stop when PC reached address 32
            instDecExec(instWord);
        }
    }
    else emitError("Cannot access input file\n");
}
